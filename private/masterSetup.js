var cluster = require('cluster');

var initAggregate = require('./initAggregate');
var merge = require('./merge');
var setupMessageHandler = require('./setupMessageHandler');


/**
 * Handles sample sets emitted by itself and sent to the master by workers.
 *
 * @param {Object} panopticon The scope to operate on.
 * @private
 */

module.exports = function (panopticon) {
	// Create the basic aggregate object.
	initAggregate(panopticon);

	// Collect samples emitted by master. These are stringified and parsed because the workers went
	// through the same process. For consistency.
	panopticon.on('sample', function (data) {

		// Apply transform to master data. This must be JSON stringified and parsed to make sure
		// that `value` (which may be generated by a `toJSON` function has been created for each
		// datum.
		var transformed = panopticon.transform(JSON.parse(JSON.stringify(data)), 'master');

		// Merge transformed data with the aggregate.
		merge(panopticon.aggregated.data, transformed);
	});

	// This closure allows us to unregister this listener when this panopticon shuts down.
	var messageHandler = function (worker) {
		setupMessageHandler(panopticon, worker);
	};

	// Collect samples emitted by existing workers.
	Object.keys(cluster.workers).forEach(function (workerId) {
		messageHandler(cluster.workers[workerId]);
	});

	// If a new worker is spawned, listen to it.
	cluster.on('fork', messageHandler);

	// If the panopticon is stopped, we should remove the listener.
	panopticon.once('stopping', function () {
		cluster.removeListener('fork', messageHandler);
	});
};
